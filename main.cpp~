#include <iostream>
#include <vector>
#include <conio.h>
#include <thread>
#include <chrono>
#include <ctime>

using namespace std;

const int height = 20, width = 20;
bool game, fall, shape_index;
time_t randseed = time(0);
vector<pair<int, int>> new_shape;
vector<vector<char>> field(height, vector<char>(width, ' '));
const vector<vector<pair<int, int>>> shapes =
  {
    {
      {2, width / 2}, {2, width / 2 - 1}, {1, width / 2}, {1, width / 2 - 1}
    },
    {
      {2, width / 2}, {2, width / 2 + 1}, {1, width / 2 - 1}, {1, width / 2}
    },
    {
      {4, width / 2}, {3, width / 2}, {2, width / 2}, {1, width / 2}
    },
    {
      {2, width / 2}, {2, width / 2 - 1}, {1, width / 2 + 1}, {1, width / 2}
    }
  }
;


void setup() {
  game = true;
  fall = false;
  srand(randseed);
  shape_index = -1;

  for (int i=0; i<width; i++) {
    field[0][i] = '#';
    field.back()[i] = '#';
  }
  for (int i=0; i<height; i++) {
    field[i][0] = '#';
    field[i].back() = '#';
  }
}


void input() {
  if (shape_index == -1) {
    return;
  }
  if (console.kbhit()) {
    bool brk = false;
    switch (console.getch())
    {
    case 'a':
      brk = true;
      for (auto pr : new_shape) {
	if (field[pr.first][pr.second - 1] != ' ') {
	  brk = false;
	  break;
	}
      }
      if (brk) {
	for (int i=0; i<new_shape.size(); i++) {
	  field[new_shape[i].first][new_shape[i].second] = ' ';
	  new_shape[i].second--;
	  field[new_shape[i].first][new_shape[i].second] = '.';
	}
      }
      break;
    case 'd':
      brk = true;
      for (auto pr : new_shape) {
	if (field[pr.first][pr.second + 1] != ' ') {
	  brk = false;
	  break;
	}
      }
      if (brk) {
	for (int i=0; i<new_shape.size(); i++) {
	  field[new_shape[i].first][new_shape[i].second] = ' ';
	  new_shape[i].second++;
	  field[new_shape[i].first][new_shape[i].second] = '.';
	}
      }
      break;
    case 'x':
      cout << "end";
      game = false;
      break;
    }
  }
}


void logic() {
  if (fall) {
    for (int i=0; i<new_shape.size(); i++) {
      field[new_shape[i].first][new_shape[i].second] = ' ';
      new_shape[i].first++;
      field[new_shape[i].first][new_shape[i].second] = '.';

      if (field[new_shape[0].first + 1][new_shape[i].second] != ' ') {
	fall = false;
      }
    }
  } else {
    // shape_index = rand() % shapes.size();
    shape_index = 2;
    new_shape = shapes[shape_index];
    for (auto p : new_shape) {
      field[p.first][p.second] = '.';
    }
    fall = true;
  }
}


void draw() {
  char clear = system("clear");
  
  for (auto i : field) {
    for (auto j : i) {
      cout << j;
    }
    cout << "\n";
  }
}


int main() {
  setup();

  while (game) {
    input();
    logic();
    draw();

    for (auto j : new_shape) {
      cout << j.first << " " << j.second << "\n";
    }
    this_thread::sleep_for(chrono::milliseconds(500));
  }
  
  return 0;
}
